#!/usr/bin/env python3
# This file is placed in the Public Domain.
# pylint: disable=C,W0212,W0718


"console"


import os
import readline
import sys
import termios
import threading
import time
import _thread


from nixt.object  import Obj, parse
from nixt.persist import Workdir, modname
from nixt.runtime import Commands, Errors, Reactor, later, launch


NAME = Errors.__module__.split(".", maxsplit=2)[-2]
Workdir.wdr = os.path.expanduser(f"~/.{NAME}")


Cfg = Obj()


if os.path.exists("mods"):
    import mods.face as MODS
else:
    MODS = None


modpathz = modname()


if os.path.exists(modpathz):
    sys.path.insert(0, modpathz)
    import mods.face as MODZ
else:
    MODZ = None


class Console(Reactor):

    def __init__(self):
        Reactor.__init__(self)
        self.register("command", command)

    def callback(self, evt):
        Reactor.callback(self, evt)
        evt.wait()

    def display(self, evt):
        for txt in evt.result:
            self.raw(txt)

    def poll(self):
        evtt = Event()
        evtt.txt = input("> ")
        return evtt

    def raw(self, txt2):
        print(txt2)


class Event:

    def __init__(self):
        self._ready  = threading.Event()
        self._thr    = None
        self.result  = []
        self.txt     = ""
        self.type    = "command"

    def __getattr__(self, key):
        return self.__dict__.get(key, "")

    def __str__(self):
        return str(self.__dict__)

    def ready(self):
        self._ready.set()

    def reply(self, txt2):
        self.result.append(txt2)

    def wait(self):
        self._ready.wait()
        if self._thr:
            self._thr.join()


def banner():
    tme = time.ctime(time.time()).replace("  ", " ")
    print(f"{NAME.upper()} since {tme}")


def errors():
    for error in Errors.errors:
        for line in error:
            print(line)


def command(bot, evt):
    parse(evt, evt.txt)
    if "ident" in dir(bot):
        evt.orig = bot.ident
    funct = Commands.cmds.get(evt.cmd, None)
    if funct:
        try:
            funct(evt)
            bot.display(evt)
        except Exception as ex:
            later(ex)
    evt.ready()


def forever():
    while not False:
        try:
            time.sleep(1.0)
        except (KeyboardInterrupt, EOFError):
            _thread.interrupt_main()


def init(*pkgs):
    mods = []
    for pkg in pkgs:
        for modb in dir(pkg):
            if modb.startswith("__"):
                continue
            modi = getattr(pkg, modb)
            if "init" not in dir(modi):
                continue
            thr = launch(modi.init, "init")
            mods.append((modi, thr))
    return mods


def scan(*pkgs):
    for pkg in pkgs:
        for mod in dir(pkg):
            if mod.startswith("__"):
                continue
            moda = getattr(pkg, mod)
            if "register" not in dir(moda):
                continue
            moda.register()


def wrap(func):
    old2 = None
    try:
        old2 = termios.tcgetattr(sys.stdin.fileno())
    except termios.error:
        pass
    try:
        func()
    except (KeyboardInterrupt, EOFError):
        print("")
    except Exception as ex:
        later(ex)
    finally:
        if old2:
            termios.tcsetattr(sys.stdin.fileno(), termios.TCSADRAIN, old2)


def main():
    parse(Cfg, " ".join(sys.argv[1:]))
    scan(MODS, MODZ)
    if "v" in Cfg.opts:
        readline.redisplay()
        banner()
    if "i" in Cfg.opts:
        for _mod, thr in init(MODS, MODZ):
            if "w" in Cfg.opts:
                thr.join()
    csl = Console()
    csl.start()
    forever()


if __name__ == "__main__":
    wrap(main)
    errors()
