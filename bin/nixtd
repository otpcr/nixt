#!/usr/bin/env python3
# This file is placed in the Public Domain.
# pylint: disable=R,W0105,C0413,W0212,W0611,W0718


"daemon"


import getpass
import os
import pathlib
import pwd
import sys
import time


sys.path.insert(0, os.getcwd())


from nixt.command import Commands, pidname, scanner
from nixt.modules import face
from nixt.object  import Obj, keys
from nixt.runtime import Broker, Errors, Event, Reactor
from nixt.runtime import forever, later, launch, init


"utilities"


def daemon(verbose=False):
    "switch to background."
    pid = os.fork()
    if pid != 0:
        os._exit(0)
    os.setsid()
    pid2 = os.fork()
    if pid2 != 0:
        os._exit(0)
    if not verbose:
        with open('/dev/null', 'r', encoding="utf-8") as sis:
            os.dup2(sis.fileno(), sys.stdin.fileno())
        with open('/dev/null', 'a+', encoding="utf-8") as sos:
            os.dup2(sos.fileno(), sys.stdout.fileno())
        with open('/dev/null', 'a+', encoding="utf-8") as ses:
            os.dup2(ses.fileno(), sys.stderr.fileno())
    os.umask(0)
    os.chdir("/")
    os.nice(10)


def pidfile(filename):
    "write the pid to a file."
    if os.path.exists(filename):
        os.unlink(filename)
    path = pathlib.Path(filename)
    path.parent.mkdir(parents=True, exist_ok=True)
    with open(filename, "w", encoding="utf-8") as fds:
        fds.write(str(os.getpid()))


def privileges(username):
    "privileges."
    pwnam = pwd.getpwnam(username)
    os.setgid(pwnam.pw_gid)
    os.setuid(pwnam.pw_uid)


def wrap(func):
    "reset console."
    try:
        func()
    except (KeyboardInterrupt, EOFError):
        print("")
    except Exception as ex:
        later(ex)


"commands"


def cmd(event):
    "list commands."
    event.reply(",".join(sorted(keys(Commands.cmds))))


"main"


def main():
    "main"
    daemon()
    privileges(getpass.getuser())
    pidfile(pidname())
    Commands.add(cmd)
    scanner(face)
    for _mod, thr in init(face):
        thr.join()
    forever()


if __name__ == "__main__":
    wrap(main)
    for error in Errors.errors:
        for line in error:
            print(line)
